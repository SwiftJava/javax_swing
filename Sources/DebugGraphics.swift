
import java_swift
import java_awt

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class javax.swing.DebugGraphics ///

open class DebugGraphics: java_awt.Graphics {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var DebugGraphicsJNIClass: jclass?

    /// java.awt.Graphics javax.swing.DebugGraphics.graphics

    /// java.awt.Image javax.swing.DebugGraphics.buffer

    /// int javax.swing.DebugGraphics.debugOptions

    /// int javax.swing.DebugGraphics.graphicsID

    /// int javax.swing.DebugGraphics.xOffset

    /// int javax.swing.DebugGraphics.yOffset

    /// private static int javax.swing.DebugGraphics.graphicsCount

    /// private static javax.swing.ImageIcon javax.swing.DebugGraphics.imageLoadingIcon

    /// public static final int javax.swing.DebugGraphics.LOG_OPTION

    private static var LOG_OPTION_FieldID: jfieldID?

    open static var LOG_OPTION: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "LOG_OPTION", fieldType: "I", fieldCache: &LOG_OPTION_FieldID, className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// public static final int javax.swing.DebugGraphics.FLASH_OPTION

    private static var FLASH_OPTION_FieldID: jfieldID?

    open static var FLASH_OPTION: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "FLASH_OPTION", fieldType: "I", fieldCache: &FLASH_OPTION_FieldID, className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// public static final int javax.swing.DebugGraphics.BUFFERED_OPTION

    private static var BUFFERED_OPTION_FieldID: jfieldID?

    open static var BUFFERED_OPTION: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "BUFFERED_OPTION", fieldType: "I", fieldCache: &BUFFERED_OPTION_FieldID, className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// public static final int javax.swing.DebugGraphics.NONE_OPTION

    private static var NONE_OPTION_FieldID: jfieldID?

    open static var NONE_OPTION: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "NONE_OPTION", fieldType: "I", fieldCache: &NONE_OPTION_FieldID, className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// private static final java.lang.Class javax.swing.DebugGraphics.debugGraphicsInfoKey

    /// public javax.swing.DebugGraphics(java.awt.Graphics)

    private static var new_MethodID_1: jmethodID?

    public convenience init( graphics: java_awt.Graphics? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: graphics != nil ? graphics! as JNIObject : nil, locals: &__locals )
        let __object = JNIMethod.NewObject( className: "javax/swing/DebugGraphics", classCache: &DebugGraphics.DebugGraphicsJNIClass, methodSig: "(Ljava/awt/Graphics;)V", methodCache: &DebugGraphics.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    public convenience init( _ _graphics: java_awt.Graphics? ) {
        self.init( graphics: _graphics )
    }

    /// public javax.swing.DebugGraphics(java.awt.Graphics,javax.swing.JComponent)

    private static var new_MethodID_2: jmethodID?

    public convenience init( graphics: java_awt.Graphics?, component: JComponent? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: graphics != nil ? graphics! as JNIObject : nil, locals: &__locals )
        __args[1] = JNIType.toJava( value: component != nil ? component! as JNIObject : nil, locals: &__locals )
        let __object = JNIMethod.NewObject( className: "javax/swing/DebugGraphics", classCache: &DebugGraphics.DebugGraphicsJNIClass, methodSig: "(Ljava/awt/Graphics;Ljavax/swing/JComponent;)V", methodCache: &DebugGraphics.new_MethodID_2, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    public convenience init( _ _graphics: java_awt.Graphics?, _ _component: JComponent? ) {
        self.init( graphics: _graphics, component: _component )
    }

    /// public javax.swing.DebugGraphics()

    private static var new_MethodID_3: jmethodID?

    public convenience init() {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __object = JNIMethod.NewObject( className: "javax/swing/DebugGraphics", classCache: &DebugGraphics.DebugGraphicsJNIClass, methodSig: "()V", methodCache: &DebugGraphics.new_MethodID_3, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// public java.awt.Graphics javax.swing.DebugGraphics.create(int,int,int,int)

    /// public java.awt.Graphics javax.swing.DebugGraphics.create()

    /// final void javax.swing.DebugGraphics.sleep(int)

    /// static javax.swing.DebugGraphicsInfo javax.swing.DebugGraphics.info()

    /// public java.awt.Color javax.swing.DebugGraphics.getColor()

    /// public void javax.swing.DebugGraphics.setColor(java.awt.Color)

    private static var setColor_MethodID_4: jmethodID?

    open func setColor( aColor: java_awt.Color? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: aColor != nil ? aColor! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setColor", methodSig: "(Ljava/awt/Color;)V", methodCache: &DebugGraphics.setColor_MethodID_4, args: &__args, locals: &__locals )
    }

    override open func setColor( _ _aColor: java_awt.Color? ) {
        setColor( aColor: _aColor )
    }

    /// private java.awt.Graphics javax.swing.DebugGraphics.debugGraphics()

    /// public static void javax.swing.DebugGraphics.setFlashColor(java.awt.Color)

    private static var setFlashColor_MethodID_5: jmethodID?

    open class func setFlashColor( flashColor: java_awt.Color? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: flashColor != nil ? flashColor! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "setFlashColor", methodSig: "(Ljava/awt/Color;)V", methodCache: &setFlashColor_MethodID_5, args: &__args, locals: &__locals )
    }

    open class func setFlashColor( _ _flashColor: java_awt.Color? ) {
        setFlashColor( flashColor: _flashColor )
    }

    /// public static java.awt.Color javax.swing.DebugGraphics.flashColor()

    private static var flashColor_MethodID_6: jmethodID?

    open class func flashColor() -> java_awt.Color! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "flashColor", methodSig: "()Ljava/awt/Color;", methodCache: &flashColor_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_awt.Color( javaObject: __return ) : nil
    }


    /// public static void javax.swing.DebugGraphics.setFlashTime(int)

    private static var setFlashTime_MethodID_7: jmethodID?

    open class func setFlashTime( flashTime: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: flashTime, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "setFlashTime", methodSig: "(I)V", methodCache: &setFlashTime_MethodID_7, args: &__args, locals: &__locals )
    }

    open class func setFlashTime( _ _flashTime: Int ) {
        setFlashTime( flashTime: _flashTime )
    }

    /// public static int javax.swing.DebugGraphics.flashTime()

    private static var flashTime_MethodID_8: jmethodID?

    open class func flashTime() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticIntMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "flashTime", methodSig: "()I", methodCache: &flashTime_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public static void javax.swing.DebugGraphics.setFlashCount(int)

    private static var setFlashCount_MethodID_9: jmethodID?

    open class func setFlashCount( flashCount: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: flashCount, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "setFlashCount", methodSig: "(I)V", methodCache: &setFlashCount_MethodID_9, args: &__args, locals: &__locals )
    }

    open class func setFlashCount( _ _flashCount: Int ) {
        setFlashCount( flashCount: _flashCount )
    }

    /// public static int javax.swing.DebugGraphics.flashCount()

    private static var flashCount_MethodID_10: jmethodID?

    open class func flashCount() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticIntMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "flashCount", methodSig: "()I", methodCache: &flashCount_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public static void javax.swing.DebugGraphics.setLogStream(java.io.PrintStream)

    private static var setLogStream_MethodID_11: jmethodID?

    open class func setLogStream( stream: /* java.io.PrintStream */ UnclassedObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: stream != nil ? stream! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "setLogStream", methodSig: "(Ljava/io/PrintStream;)V", methodCache: &setLogStream_MethodID_11, args: &__args, locals: &__locals )
    }

    open class func setLogStream( _ _stream: /* java.io.PrintStream */ UnclassedObject? ) {
        setLogStream( stream: _stream )
    }

    /// public static java.io.PrintStream javax.swing.DebugGraphics.logStream()

    private static var logStream_MethodID_12: jmethodID?

    open class func logStream() -> /* java.io.PrintStream */ UnclassedObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/DebugGraphics", classCache: &DebugGraphicsJNIClass, methodName: "logStream", methodSig: "()Ljava/io/PrintStream;", methodCache: &logStream_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* java.io.PrintStream */ UnclassedObject( javaObject: __return ) : nil
    }


    /// public void javax.swing.DebugGraphics.setPaintMode()

    /// public void javax.swing.DebugGraphics.setXORMode(java.awt.Color)

    private static var setXORMode_MethodID_13: jmethodID?

    open func setXORMode( aColor: java_awt.Color? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: aColor != nil ? aColor! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setXORMode", methodSig: "(Ljava/awt/Color;)V", methodCache: &DebugGraphics.setXORMode_MethodID_13, args: &__args, locals: &__locals )
    }

    override open func setXORMode( _ _aColor: java_awt.Color? ) {
        setXORMode( aColor: _aColor )
    }

    /// public java.awt.Rectangle javax.swing.DebugGraphics.getClipBounds()

    /// public void javax.swing.DebugGraphics.drawRect(int,int,int,int)

    /// public void javax.swing.DebugGraphics.drawRoundRect(int,int,int,int,int,int)

    /// public void javax.swing.DebugGraphics.fillRoundRect(int,int,int,int,int,int)

    /// public void javax.swing.DebugGraphics.drawLine(int,int,int,int)

    /// public void javax.swing.DebugGraphics.draw3DRect(int,int,int,int,boolean)

    /// public void javax.swing.DebugGraphics.fill3DRect(int,int,int,int,boolean)

    /// public void javax.swing.DebugGraphics.drawOval(int,int,int,int)

    /// public void javax.swing.DebugGraphics.fillOval(int,int,int,int)

    /// public void javax.swing.DebugGraphics.drawArc(int,int,int,int,int,int)

    /// public void javax.swing.DebugGraphics.fillArc(int,int,int,int,int,int)

    /// public void javax.swing.DebugGraphics.drawPolyline(int[],int[],int)

    /// public void javax.swing.DebugGraphics.drawPolygon(int[],int[],int)

    /// public void javax.swing.DebugGraphics.fillPolygon(int[],int[],int)

    /// public void javax.swing.DebugGraphics.drawString(java.text.AttributedCharacterIterator,int,int)

    /// public void javax.swing.DebugGraphics.drawString(java.lang.String,int,int)

    private static var drawString_MethodID_14: jmethodID?

    open func drawString( aString: String?, x: Int, y: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: aString, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        __args[2] = JNIType.toJava( value: y, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "drawString", methodSig: "(Ljava/lang/String;II)V", methodCache: &DebugGraphics.drawString_MethodID_14, args: &__args, locals: &__locals )
    }

    override open func drawString( _ _aString: String?, _ _x: Int, _ _y: Int ) {
        drawString( aString: _aString, x: _x, y: _y )
    }

    /// public void javax.swing.DebugGraphics.drawBytes(byte[],int,int,int,int)

    /// public void javax.swing.DebugGraphics.drawChars(char[],int,int,int,int)

    /// static void javax.swing.DebugGraphics.loadImage(java.awt.Image)

    /// public boolean javax.swing.DebugGraphics.isDrawingBuffer()

    private static var isDrawingBuffer_MethodID_15: jmethodID?

    open func isDrawingBuffer() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isDrawingBuffer", methodSig: "()Z", methodCache: &DebugGraphics.isDrawingBuffer_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// java.lang.String javax.swing.DebugGraphics.toShortString()

    /// java.lang.String javax.swing.DebugGraphics.pointToString(int,int)

    /// public void javax.swing.DebugGraphics.setDebugOptions(int)

    private static var setDebugOptions_MethodID_16: jmethodID?

    open func setDebugOptions( options: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: options, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setDebugOptions", methodSig: "(I)V", methodCache: &DebugGraphics.setDebugOptions_MethodID_16, args: &__args, locals: &__locals )
    }

    open func setDebugOptions( _ _options: Int ) {
        setDebugOptions( options: _options )
    }

    /// static void javax.swing.DebugGraphics.setDebugOptions(javax.swing.JComponent,int)

    /// static int javax.swing.DebugGraphics.getDebugOptions(javax.swing.JComponent)

    /// public int javax.swing.DebugGraphics.getDebugOptions()

    private static var getDebugOptions_MethodID_17: jmethodID?

    open func getDebugOptions() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getDebugOptions", methodSig: "()I", methodCache: &DebugGraphics.getDebugOptions_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// static int javax.swing.DebugGraphics.shouldComponentDebug(javax.swing.JComponent)

    /// static int javax.swing.DebugGraphics.debugComponentCount()

    /// boolean javax.swing.DebugGraphics.debugLog()

    /// boolean javax.swing.DebugGraphics.debugFlash()

    /// boolean javax.swing.DebugGraphics.debugBuffered()

    /// public void javax.swing.DebugGraphics.dispose()

    /// public void javax.swing.DebugGraphics.copyArea(int,int,int,int,int,int)

    private static var copyArea_MethodID_18: jmethodID?

    open func copyArea( x: Int, y: Int, width: Int, height: Int, destX: Int, destY: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: x, locals: &__locals )
        __args[1] = JNIType.toJava( value: y, locals: &__locals )
        __args[2] = JNIType.toJava( value: width, locals: &__locals )
        __args[3] = JNIType.toJava( value: height, locals: &__locals )
        __args[4] = JNIType.toJava( value: destX, locals: &__locals )
        __args[5] = JNIType.toJava( value: destY, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "copyArea", methodSig: "(IIIIII)V", methodCache: &DebugGraphics.copyArea_MethodID_18, args: &__args, locals: &__locals )
    }

    override open func copyArea( _ _x: Int, _ _y: Int, _ _width: Int, _ _height: Int, _ _destX: Int, _ _destY: Int ) {
        copyArea( x: _x, y: _y, width: _width, height: _height, destX: _destX, destY: _destY )
    }

    /// public void javax.swing.DebugGraphics.translate(int,int)

    /// public void javax.swing.DebugGraphics.setClip(java.awt.Shape)

    /// public void javax.swing.DebugGraphics.setClip(int,int,int,int)

    /// public void javax.swing.DebugGraphics.clipRect(int,int,int,int)

    /// public void javax.swing.DebugGraphics.clearRect(int,int,int,int)

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver)

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver)

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver)

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver)

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)

    private static var drawImage_MethodID_19: jmethodID?

    override open func drawImage( img: java_awt.Image?, dx1: Int, dy1: Int, dx2: Int, dy2: Int, sx1: Int, sy1: Int, sx2: Int, sy2: Int, bgcolor: java_awt.Color?, observer: java_awt.ImageObserver? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 11 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: img != nil ? img! as JNIObject : nil, locals: &__locals )
        __args[1] = JNIType.toJava( value: dx1, locals: &__locals )
        __args[2] = JNIType.toJava( value: dy1, locals: &__locals )
        __args[3] = JNIType.toJava( value: dx2, locals: &__locals )
        __args[4] = JNIType.toJava( value: dy2, locals: &__locals )
        __args[5] = JNIType.toJava( value: sx1, locals: &__locals )
        __args[6] = JNIType.toJava( value: sy1, locals: &__locals )
        __args[7] = JNIType.toJava( value: sx2, locals: &__locals )
        __args[8] = JNIType.toJava( value: sy2, locals: &__locals )
        __args[9] = JNIType.toJava( value: bgcolor != nil ? bgcolor! as JNIObject : nil, locals: &__locals )
        __args[10] = JNIType.toJava( value: observer, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "drawImage", methodSig: "(Ljava/awt/Image;IIIIIIIILjava/awt/Color;Ljava/awt/image/ImageObserver;)Z", methodCache: &DebugGraphics.drawImage_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func drawImage( _ _img: java_awt.Image?, _ _dx1: Int, _ _dy1: Int, _ _dx2: Int, _ _dy2: Int, _ _sx1: Int, _ _sy1: Int, _ _sx2: Int, _ _sy2: Int, _ _bgcolor: java_awt.Color?, _ _observer: java_awt.ImageObserver? ) -> Bool {
        return drawImage( img: _img, dx1: _dx1, dy1: _dy1, dx2: _dx2, dy2: _dy2, sx1: _sx1, sy1: _sy1, sx2: _sx2, sy2: _sy2, bgcolor: _bgcolor, observer: _observer )
    }

    /// public boolean javax.swing.DebugGraphics.drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)

    /// public java.awt.Font javax.swing.DebugGraphics.getFont()

    /// public java.awt.FontMetrics javax.swing.DebugGraphics.getFontMetrics()

    /// public java.awt.FontMetrics javax.swing.DebugGraphics.getFontMetrics(java.awt.Font)

    /// public void javax.swing.DebugGraphics.setFont(java.awt.Font)

    private static var setFont_MethodID_20: jmethodID?

    open func setFont( aFont: java_awt.Font? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: aFont != nil ? aFont! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFont", methodSig: "(Ljava/awt/Font;)V", methodCache: &DebugGraphics.setFont_MethodID_20, args: &__args, locals: &__locals )
    }

    override open func setFont( _ _aFont: java_awt.Font? ) {
        setFont( aFont: _aFont )
    }

    /// public java.awt.Shape javax.swing.DebugGraphics.getClip()

    /// public void javax.swing.DebugGraphics.fillRect(int,int,int,int)

}

