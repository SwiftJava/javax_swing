
import java_swift
import java_awt

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class javax.swing.text.AsyncBoxView ///

open class AsyncBoxView: View {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var AsyncBoxViewJNIClass: jclass?

    /// int javax.swing.text.AsyncBoxView.axis

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.bottomInset

    // Skipping field: true false false false false false 

    /// javax.swing.text.AsyncBoxView$ChildState javax.swing.text.AsyncBoxView.changing

    // Skipping field: true false false false false false 

    /// boolean javax.swing.text.AsyncBoxView.estimatedMajorSpan

    // Skipping field: true false false false false false 

    /// java.lang.Runnable javax.swing.text.AsyncBoxView.flushTask

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.leftInset

    // Skipping field: true false false false false false 

    /// protected javax.swing.text.AsyncBoxView$ChildLocator javax.swing.text.AsyncBoxView.locator

    private static var locator_FieldID: jfieldID?

    open var locator: AsyncBoxView_ChildLocator! {
        get {
            let __value = JNIField.GetObjectField( fieldName: "locator", fieldType: "Ljavax/swing/text/AsyncBoxView$ChildLocator;", fieldCache: &AsyncBoxView.locator_FieldID, object: javaObject )
            defer { JNI.DeleteLocalRef( __value ) }
            return __value != nil ? AsyncBoxView_ChildLocator( javaObject: __value ) : nil
        }
        set(newValue) {
            var __locals = [jobject]()
            let __value = JNIType.toJava( value: newValue, locals: &__locals )
            JNIField.SetObjectField( fieldName: "locator", fieldType: "Ljavax/swing/text/AsyncBoxView$ChildLocator;", fieldCache: &AsyncBoxView.locator_FieldID, object: javaObject, value: __value.l, locals: &__locals )
        }
    }

    /// boolean javax.swing.text.AsyncBoxView.majorChanged

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.majorSpan

    // Skipping field: true false false false false false 

    /// javax.swing.text.AsyncBoxView$ChildState javax.swing.text.AsyncBoxView.minRequest

    // Skipping field: true false false false false false 

    /// boolean javax.swing.text.AsyncBoxView.minorChanged

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.minorSpan

    // Skipping field: true false false false false false 

    /// javax.swing.text.AsyncBoxView$ChildState javax.swing.text.AsyncBoxView.prefRequest

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.rightInset

    // Skipping field: true false false false false false 

    /// java.util.List javax.swing.text.AsyncBoxView.stats

    // Skipping field: true false false false false false 

    /// float javax.swing.text.AsyncBoxView.topInset

    // Skipping field: true false false false false false 

    /// public static final int javax.swing.text.View.BadBreakWeight

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.text.View.ExcellentBreakWeight

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.text.View.ForcedBreakWeight

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.text.View.GoodBreakWeight

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.text.View.X_AXIS

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.text.View.Y_AXIS

    // Skipping field: false true false false false false 

    /// static final javax.swing.text.Position$Bias[] javax.swing.text.View.sharedBiasReturn

    // Skipping field: true false false false false false 

    /// private javax.swing.text.Element javax.swing.text.View.elem

    /// int javax.swing.text.View.firstUpdateIndex

    // Skipping field: true false false false false false 

    /// int javax.swing.text.View.lastUpdateIndex

    // Skipping field: true false false false false false 

    /// private javax.swing.text.View javax.swing.text.View.parent

    /// public static final int javax.swing.SwingConstants.BOTTOM

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.CENTER

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.EAST

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.HORIZONTAL

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.LEADING

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.LEFT

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.NEXT

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.NORTH

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.NORTH_EAST

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.NORTH_WEST

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.PREVIOUS

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.RIGHT

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.SOUTH

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.SOUTH_EAST

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.SOUTH_WEST

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.TOP

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.TRAILING

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.VERTICAL

    // Skipping field: false true false false false false 

    /// public static final int javax.swing.SwingConstants.WEST

    // Skipping field: false true false false false false 

    /// public javax.swing.text.AsyncBoxView(javax.swing.text.Element,int)

    private static var new_MethodID_1: jmethodID?

    public convenience init( elem: Element?, axis: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: elem, locals: &__locals )
        __args[1] = jvalue( i: jint(axis) )
        let __object = JNIMethod.NewObject( className: "javax/swing/text/AsyncBoxView", classCache: &AsyncBoxView.AsyncBoxViewJNIClass, methodSig: "(Ljavax/swing/text/Element;I)V", methodCache: &AsyncBoxView.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    public convenience init( _ _elem: Element?, _ _axis: Int ) {
        self.init( elem: _elem, axis: _axis )
    }

    /// protected javax.swing.text.AsyncBoxView$ChildState javax.swing.text.AsyncBoxView.createChildState(javax.swing.text.View)

    private static var createChildState_MethodID_2: jmethodID?

    open func createChildState( v: View? ) -> AsyncBoxView_ChildState! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: v, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createChildState", methodSig: "(Ljavax/swing/text/View;)Ljavax/swing/text/AsyncBoxView$ChildState;", methodCache: &AsyncBoxView.createChildState_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AsyncBoxView_ChildState( javaObject: __return ) : nil
    }

    open func createChildState( _ _v: View? ) -> AsyncBoxView_ChildState! {
        return createChildState( v: _v )
    }

    /// protected void javax.swing.text.AsyncBoxView.flushRequirementChanges()

    private static var flushRequirementChanges_MethodID_3: jmethodID?

    open func flushRequirementChanges() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "flushRequirementChanges", methodSig: "()V", methodCache: &AsyncBoxView.flushRequirementChanges_MethodID_3, args: &__args, locals: &__locals )
    }


    /// public float javax.swing.text.AsyncBoxView.getBottomInset()

    private static var getBottomInset_MethodID_4: jmethodID?

    open func getBottomInset() -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallFloatMethod( object: javaObject, methodName: "getBottomInset", methodSig: "()F", methodCache: &AsyncBoxView.getBottomInset_MethodID_4, args: &__args, locals: &__locals )
        return __return
    }


    /// public java.awt.Shape javax.swing.text.AsyncBoxView.getChildAllocation(int,java.awt.Shape)

    // Skipping method: false true false false false 

    /// protected javax.swing.text.AsyncBoxView$ChildState javax.swing.text.AsyncBoxView.getChildState(int)

    private static var getChildState_MethodID_5: jmethodID?

    open func getChildState( index: Int ) -> AsyncBoxView_ChildState! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getChildState", methodSig: "(I)Ljavax/swing/text/AsyncBoxView$ChildState;", methodCache: &AsyncBoxView.getChildState_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AsyncBoxView_ChildState( javaObject: __return ) : nil
    }

    open func getChildState( _ _index: Int ) -> AsyncBoxView_ChildState! {
        return getChildState( index: _index )
    }

    /// protected boolean javax.swing.text.AsyncBoxView.getEstimatedMajorSpan()

    private static var getEstimatedMajorSpan_MethodID_6: jmethodID?

    open func getEstimatedMajorSpan() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getEstimatedMajorSpan", methodSig: "()Z", methodCache: &AsyncBoxView.getEstimatedMajorSpan_MethodID_6, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// protected float javax.swing.text.AsyncBoxView.getInsetSpan(int)

    private static var getInsetSpan_MethodID_7: jmethodID?

    open func getInsetSpan( axis: Int ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(axis) )
        let __return = JNIMethod.CallFloatMethod( object: javaObject, methodName: "getInsetSpan", methodSig: "(I)F", methodCache: &AsyncBoxView.getInsetSpan_MethodID_7, args: &__args, locals: &__locals )
        return __return
    }

    open func getInsetSpan( _ _axis: Int ) -> Float {
        return getInsetSpan( axis: _axis )
    }

    /// protected javax.swing.text.LayoutQueue javax.swing.text.AsyncBoxView.getLayoutQueue()

    private static var getLayoutQueue_MethodID_8: jmethodID?

    open func getLayoutQueue() -> LayoutQueue! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLayoutQueue", methodSig: "()Ljavax/swing/text/LayoutQueue;", methodCache: &AsyncBoxView.getLayoutQueue_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LayoutQueue( javaObject: __return ) : nil
    }


    /// public float javax.swing.text.AsyncBoxView.getLeftInset()

    private static var getLeftInset_MethodID_9: jmethodID?

    open func getLeftInset() -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallFloatMethod( object: javaObject, methodName: "getLeftInset", methodSig: "()F", methodCache: &AsyncBoxView.getLeftInset_MethodID_9, args: &__args, locals: &__locals )
        return __return
    }


    /// public int javax.swing.text.AsyncBoxView.getMajorAxis()

    private static var getMajorAxis_MethodID_10: jmethodID?

    open func getMajorAxis() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMajorAxis", methodSig: "()I", methodCache: &AsyncBoxView.getMajorAxis_MethodID_10, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public float javax.swing.text.AsyncBoxView.getMaximumSpan(int)

    // Skipping method: false true false false false 

    /// public float javax.swing.text.AsyncBoxView.getMinimumSpan(int)

    // Skipping method: false true false false false 

    /// public int javax.swing.text.AsyncBoxView.getMinorAxis()

    private static var getMinorAxis_MethodID_11: jmethodID?

    open func getMinorAxis() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMinorAxis", methodSig: "()I", methodCache: &AsyncBoxView.getMinorAxis_MethodID_11, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public int javax.swing.text.AsyncBoxView.getNextVisualPositionFrom(int,javax.swing.text.Position$Bias,java.awt.Shape,int,javax.swing.text.Position$Bias[]) throws javax.swing.text.BadLocationException

    // Skipping method: false true false false false 

    /// public float javax.swing.text.AsyncBoxView.getPreferredSpan(int)

    // Skipping method: false true false false false 

    /// public float javax.swing.text.AsyncBoxView.getRightInset()

    private static var getRightInset_MethodID_12: jmethodID?

    open func getRightInset() -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallFloatMethod( object: javaObject, methodName: "getRightInset", methodSig: "()F", methodCache: &AsyncBoxView.getRightInset_MethodID_12, args: &__args, locals: &__locals )
        return __return
    }


    /// float javax.swing.text.AsyncBoxView.getSpanOnAxis(int)

    // Skipping method: true false false false false 

    /// public float javax.swing.text.AsyncBoxView.getTopInset()

    private static var getTopInset_MethodID_13: jmethodID?

    open func getTopInset() -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallFloatMethod( object: javaObject, methodName: "getTopInset", methodSig: "()F", methodCache: &AsyncBoxView.getTopInset_MethodID_13, args: &__args, locals: &__locals )
        return __return
    }


    /// public javax.swing.text.View javax.swing.text.AsyncBoxView.getView(int)

    // Skipping method: false true false false false 

    /// public int javax.swing.text.AsyncBoxView.getViewCount()

    // Skipping method: false true false false false 

    /// public int javax.swing.text.AsyncBoxView.getViewIndex(int,javax.swing.text.Position$Bias)

    // Skipping method: false true false false false 

    /// protected synchronized int javax.swing.text.AsyncBoxView.getViewIndexAtPosition(int,javax.swing.text.Position$Bias)

    private static var getViewIndexAtPosition_MethodID_14: jmethodID?

    open func getViewIndexAtPosition( pos: Int, b: Position_Bias? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(pos) )
        __args[1] = JNIType.toJava( value: b, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getViewIndexAtPosition", methodSig: "(ILjavax/swing/text/Position$Bias;)I", methodCache: &AsyncBoxView.getViewIndexAtPosition_MethodID_14, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open func getViewIndexAtPosition( _ _pos: Int, _ _b: Position_Bias? ) -> Int {
        return getViewIndexAtPosition( pos: _pos, b: _b )
    }

    /// protected void javax.swing.text.AsyncBoxView.loadChildren(javax.swing.text.ViewFactory)

    private static var loadChildren_MethodID_15: jmethodID?

    open func loadChildren( f: ViewFactory? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: f, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "loadChildren", methodSig: "(Ljavax/swing/text/ViewFactory;)V", methodCache: &AsyncBoxView.loadChildren_MethodID_15, args: &__args, locals: &__locals )
    }

    open func loadChildren( _ _f: ViewFactory? ) {
        loadChildren( f: _f )
    }

    /// protected synchronized void javax.swing.text.AsyncBoxView.majorRequirementChange(javax.swing.text.AsyncBoxView$ChildState,float)

    private static var majorRequirementChange_MethodID_16: jmethodID?

    open func majorRequirementChange( cs: AsyncBoxView_ChildState?, delta: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: cs, locals: &__locals )
        __args[1] = jvalue( f: delta )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "majorRequirementChange", methodSig: "(Ljavax/swing/text/AsyncBoxView$ChildState;F)V", methodCache: &AsyncBoxView.majorRequirementChange_MethodID_16, args: &__args, locals: &__locals )
    }

    open func majorRequirementChange( _ _cs: AsyncBoxView_ChildState?, _ _delta: Float ) {
        majorRequirementChange( cs: _cs, delta: _delta )
    }

    /// protected synchronized void javax.swing.text.AsyncBoxView.minorRequirementChange(javax.swing.text.AsyncBoxView$ChildState)

    private static var minorRequirementChange_MethodID_17: jmethodID?

    open func minorRequirementChange( cs: AsyncBoxView_ChildState? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: cs, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "minorRequirementChange", methodSig: "(Ljavax/swing/text/AsyncBoxView$ChildState;)V", methodCache: &AsyncBoxView.minorRequirementChange_MethodID_17, args: &__args, locals: &__locals )
    }

    open func minorRequirementChange( _ _cs: AsyncBoxView_ChildState? ) {
        minorRequirementChange( cs: _cs )
    }

    /// public java.awt.Shape javax.swing.text.AsyncBoxView.modelToView(int,java.awt.Shape,javax.swing.text.Position$Bias) throws javax.swing.text.BadLocationException

    // Skipping method: false true false false false 

    /// public void javax.swing.text.AsyncBoxView.paint(java.awt.Graphics,java.awt.Shape)

    private static var paint_MethodID_18: jmethodID?

    open func paint( g: java_awt.Graphics?, alloc: java_awt.Shape? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: g, locals: &__locals )
        __args[1] = JNIType.toJava( value: alloc, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "paint", methodSig: "(Ljava/awt/Graphics;Ljava/awt/Shape;)V", methodCache: &AsyncBoxView.paint_MethodID_18, args: &__args, locals: &__locals )
    }

    override open func paint( _ _g: java_awt.Graphics?, _ _alloc: java_awt.Shape? ) {
        paint( g: _g, alloc: _alloc )
    }

    /// public synchronized void javax.swing.text.AsyncBoxView.preferenceChanged(javax.swing.text.View,boolean,boolean)

    // Skipping method: false true false false false 

    /// public void javax.swing.text.AsyncBoxView.replace(int,int,javax.swing.text.View[])

    // Skipping method: false true false false false 

    /// public void javax.swing.text.AsyncBoxView.setBottomInset(float)

    private static var setBottomInset_MethodID_19: jmethodID?

    open func setBottomInset( i: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: i )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBottomInset", methodSig: "(F)V", methodCache: &AsyncBoxView.setBottomInset_MethodID_19, args: &__args, locals: &__locals )
    }

    open func setBottomInset( _ _i: Float ) {
        setBottomInset( i: _i )
    }

    /// protected void javax.swing.text.AsyncBoxView.setEstimatedMajorSpan(boolean)

    private static var setEstimatedMajorSpan_MethodID_20: jmethodID?

    open func setEstimatedMajorSpan( isEstimated: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(isEstimated ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setEstimatedMajorSpan", methodSig: "(Z)V", methodCache: &AsyncBoxView.setEstimatedMajorSpan_MethodID_20, args: &__args, locals: &__locals )
    }

    open func setEstimatedMajorSpan( _ _isEstimated: Bool ) {
        setEstimatedMajorSpan( isEstimated: _isEstimated )
    }

    /// public void javax.swing.text.AsyncBoxView.setLeftInset(float)

    private static var setLeftInset_MethodID_21: jmethodID?

    open func setLeftInset( i: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: i )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLeftInset", methodSig: "(F)V", methodCache: &AsyncBoxView.setLeftInset_MethodID_21, args: &__args, locals: &__locals )
    }

    open func setLeftInset( _ _i: Float ) {
        setLeftInset( i: _i )
    }

    /// public void javax.swing.text.AsyncBoxView.setParent(javax.swing.text.View)

    // Skipping method: false true false false false 

    /// public void javax.swing.text.AsyncBoxView.setRightInset(float)

    private static var setRightInset_MethodID_22: jmethodID?

    open func setRightInset( i: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: i )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setRightInset", methodSig: "(F)V", methodCache: &AsyncBoxView.setRightInset_MethodID_22, args: &__args, locals: &__locals )
    }

    open func setRightInset( _ _i: Float ) {
        setRightInset( i: _i )
    }

    /// public void javax.swing.text.AsyncBoxView.setSize(float,float)

    // Skipping method: false true false false false 

    /// void javax.swing.text.AsyncBoxView.setSpanOnAxis(int,float)

    // Skipping method: true false false false false 

    /// public void javax.swing.text.AsyncBoxView.setTopInset(float)

    private static var setTopInset_MethodID_23: jmethodID?

    open func setTopInset( i: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: i )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTopInset", methodSig: "(F)V", methodCache: &AsyncBoxView.setTopInset_MethodID_23, args: &__args, locals: &__locals )
    }

    open func setTopInset( _ _i: Float ) {
        setTopInset( i: _i )
    }

    /// protected void javax.swing.text.AsyncBoxView.updateLayout(javax.swing.event.DocumentEvent$ElementChange,javax.swing.event.DocumentEvent,java.awt.Shape)

    private static var updateLayout_MethodID_24: jmethodID?

    override open func updateLayout( ec: DocumentEvent_ElementChange?, e: DocumentEvent?, a: java_awt.Shape? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: ec, locals: &__locals )
        __args[1] = JNIType.toJava( value: e, locals: &__locals )
        __args[2] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "updateLayout", methodSig: "(Ljavax/swing/event/DocumentEvent$ElementChange;Ljavax/swing/event/DocumentEvent;Ljava/awt/Shape;)V", methodCache: &AsyncBoxView.updateLayout_MethodID_24, args: &__args, locals: &__locals )
    }

    override open func updateLayout( _ _ec: DocumentEvent_ElementChange?, _ _e: DocumentEvent?, _ _a: java_awt.Shape? ) {
        updateLayout( ec: _ec, e: _e, a: _a )
    }

    /// public int javax.swing.text.AsyncBoxView.viewToModel(float,float,java.awt.Shape,javax.swing.text.Position$Bias[])

    // Skipping method: false true false false false 

}

