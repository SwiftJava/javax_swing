
import java_swift
import java_util
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class javax.swing.RowFilter ///

open class RowFilter: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var RowFilterJNIClass: jclass?

    /// public javax.swing.RowFilter()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __object = JNIMethod.NewObject( className: "javax/swing/RowFilter", classCache: &RowFilter.RowFilterJNIClass, methodSig: "()V", methodCache: &RowFilter.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// static void javax.swing.RowFilter.access$000(int[])

    // Skipping method: true false false false false 

    /// public static javax.swing.RowFilter javax.swing.RowFilter.andFilter(java.lang.Iterable)

    private static var andFilter_MethodID_2: jmethodID?

    open class func andFilter( filters: java_lang.Iterable? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: filters, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "andFilter", methodSig: "(Ljava/lang/Iterable;)Ljavax/swing/RowFilter;", methodCache: &andFilter_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func andFilter( _ _filters: java_lang.Iterable? ) -> RowFilter! {
        return andFilter( filters: _filters )
    }

    /// private static void javax.swing.RowFilter.checkIndices(int[])

    /// public static javax.swing.RowFilter javax.swing.RowFilter.dateFilter(javax.swing.RowFilter$ComparisonType,java.util.Date,int[])

    private static var dateFilter_MethodID_3: jmethodID?

    open class func dateFilter( type: RowFilter_ComparisonType?, date: java_util.Date?, indices: [Int32]? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: type, locals: &__locals )
        __args[1] = JNIType.toJava( value: date, locals: &__locals )
        __args[2] = JNIType.toJava( value: indices, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "dateFilter", methodSig: "(Ljavax/swing/RowFilter$ComparisonType;Ljava/util/Date;[I)Ljavax/swing/RowFilter;", methodCache: &dateFilter_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func dateFilter( _ _type: RowFilter_ComparisonType?, _ _date: java_util.Date?, _ _indices: [Int32]? ) -> RowFilter! {
        return dateFilter( type: _type, date: _date, indices: _indices )
    }

    /// public static javax.swing.RowFilter javax.swing.RowFilter.notFilter(javax.swing.RowFilter)

    private static var notFilter_MethodID_4: jmethodID?

    open class func notFilter( filter: RowFilter? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: filter, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "notFilter", methodSig: "(Ljavax/swing/RowFilter;)Ljavax/swing/RowFilter;", methodCache: &notFilter_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func notFilter( _ _filter: RowFilter? ) -> RowFilter! {
        return notFilter( filter: _filter )
    }

    /// public static javax.swing.RowFilter javax.swing.RowFilter.numberFilter(javax.swing.RowFilter$ComparisonType,java.lang.Number,int[])

    private static var numberFilter_MethodID_5: jmethodID?

    open class func numberFilter( type: RowFilter_ComparisonType?, number: java_lang.Number?, indices: [Int32]? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: type, locals: &__locals )
        __args[1] = JNIType.toJava( value: number, locals: &__locals )
        __args[2] = JNIType.toJava( value: indices, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "numberFilter", methodSig: "(Ljavax/swing/RowFilter$ComparisonType;Ljava/lang/Number;[I)Ljavax/swing/RowFilter;", methodCache: &numberFilter_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func numberFilter( _ _type: RowFilter_ComparisonType?, _ _number: java_lang.Number?, _ _indices: [Int32]? ) -> RowFilter! {
        return numberFilter( type: _type, number: _number, indices: _indices )
    }

    /// public static javax.swing.RowFilter javax.swing.RowFilter.orFilter(java.lang.Iterable)

    private static var orFilter_MethodID_6: jmethodID?

    open class func orFilter( filters: java_lang.Iterable? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: filters, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "orFilter", methodSig: "(Ljava/lang/Iterable;)Ljavax/swing/RowFilter;", methodCache: &orFilter_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func orFilter( _ _filters: java_lang.Iterable? ) -> RowFilter! {
        return orFilter( filters: _filters )
    }

    /// public static javax.swing.RowFilter javax.swing.RowFilter.regexFilter(java.lang.String,int[])

    private static var regexFilter_MethodID_7: jmethodID?

    open class func regexFilter( regex: String?, indices: [Int32]? ) -> RowFilter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: regex, locals: &__locals )
        __args[1] = JNIType.toJava( value: indices, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "javax/swing/RowFilter", classCache: &RowFilterJNIClass, methodName: "regexFilter", methodSig: "(Ljava/lang/String;[I)Ljavax/swing/RowFilter;", methodCache: &regexFilter_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? RowFilter( javaObject: __return ) : nil
    }

    open class func regexFilter( _ _regex: String?, _ _indices: [Int32]? ) -> RowFilter! {
        return regexFilter( regex: _regex, indices: _indices )
    }

    /// public abstract boolean javax.swing.RowFilter.include(javax.swing.RowFilter$Entry)

    private static var include_MethodID_8: jmethodID?

    open func include( entry: RowFilter_Entry? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: entry, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "include", methodSig: "(Ljavax/swing/RowFilter$Entry;)Z", methodCache: &RowFilter.include_MethodID_8, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func include( _ _entry: RowFilter_Entry? ) -> Bool {
        return include( entry: _entry )
    }

}

